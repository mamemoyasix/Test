<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>XANY SYSTEM - OZ STYLE</title>
    <style>
      /* --- OZ風デザイン設定 (Superflat / Pop / White) --- */
      :root {
        --bg-color: #ffffff; /* 真っ白な背景 */
        --text-main: #333333;
        --accent-red: #e73c3c; /* OZ特有の赤 */
        --ui-bg: rgba(255, 255, 255, 0.85);
        --border-color: #e73c3c;
        --font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: var(--bg-color);
        font-family: var(--font-family);
        color: var(--text-main);
      }

      /* 3D Canvas */
      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }
      /* Webモード時は少しぼかす */
      body.web-mode #canvas-container {
        filter: blur(5px) opacity(0.3);
      }

      /* UI Layer */
      #ui-layer {
        position: absolute;
        top: 30px;
        left: 30px;
        z-index: 10;
        pointer-events: none;
        transition: opacity 0.5s;
      }
      body.web-mode #ui-layer {
        opacity: 0;
      }

      h1 {
        font-size: 4rem;
        font-weight: 800;
        margin: 0;
        line-height: 0.9;
        color: var(--accent-red);
        text-shadow: 2px 2px 0px #000; /* ポップな影 */
        font-family: "Arial Black", sans-serif;
        letter-spacing: -2px;
      }
      h1 span {
        color: #333;
      }
      p.subtitle {
        margin-top: 5px;
        color: #555;
        font-weight: bold;
        background: var(--text-main);
        color: white;
        display: inline-block;
        padding: 2px 10px;
        border-radius: 10px;
        font-size: 0.8rem;
      }

      /* 戻るボタン (カプセル型) */
      #back-btn {
        pointer-events: auto;
        background: var(--accent-red);
        border: 2px solid white;
        color: white;
        padding: 10px 30px;
        border-radius: 30px;
        cursor: pointer;
        margin-top: 20px;
        display: none;
        font-weight: bold;
        box-shadow: 0 4px 10px rgba(231, 60, 60, 0.4);
        transition: 0.2s;
      }
      #back-btn:hover {
        transform: scale(1.05);
      }

      /* AI Interface (John / King Kazma Style HUD) */
      #ai-container {
        position: fixed;
        bottom: 30px;
        left: 30px;
        z-index: 100;
        display: flex;
        align-items: flex-end;
        gap: 15px;
        pointer-events: auto;
      }

      #ai-core {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: white;
        border: 4px solid var(--accent-red);
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }
      /* AIの顔（仮：デジタルな目） */
      #ai-core::before {
        content: "( •_• )";
        font-weight: bold;
        color: var(--accent-red);
        font-size: 1.2rem;
      }
      #ai-core.speaking {
        border-color: #333;
        animation: bounce 0.5s infinite;
      }
      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-5px);
        }
      }

      #ai-message {
        background: white;
        border: 2px solid var(--text-main);
        padding: 15px 20px;
        border-radius: 20px 20px 20px 0;
        max-width: 300px;
        font-size: 0.9rem;
        font-weight: bold;
        color: #333;
        box-shadow: 5px 5px 0px rgba(0, 0, 0, 0.1);
        opacity: 0;
        transform: scale(0.8);
        transform-origin: bottom left;
        transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      #ai-message.active {
        opacity: 1;
        transform: scale(1);
      }

      /* Start Overlay */
      #start-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: white;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
      }
      #start-overlay h2 {
        font-size: 3rem;
        color: var(--accent-red);
        font-weight: 900;
        text-shadow: 3px 3px 0 #000;
      }
      #start-overlay p {
        color: #333;
        font-weight: bold;
        margin-top: 10px;
        background: #eee;
        padding: 5px 15px;
        border-radius: 20px;
      }

      /* Web View (Pop & Clean) */
      #web-view {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 20;
        overflow-y: auto;
        padding: 0;
        box-sizing: border-box;
        background: rgba(255, 255, 255, 0.95);
      }
      body.web-mode #web-view {
        display: block;
      }

      .content-wrapper {
        max-width: 1000px;
        margin: 100px auto;
        padding: 0 40px;
      }
      .web-header h2 {
        font-size: 3rem;
        color: var(--accent-red);
        font-weight: 800;
        border-bottom: 4px solid #333;
        display: inline-block;
        padding-bottom: 5px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-top: 40px;
      }

      .card {
        background: white;
        border: 2px solid #ddd;
        border-radius: 12px;
        padding: 20px;
        cursor: pointer;
        transition: 0.2s;
        position: relative;
        box-shadow: 0 4px 0 #eee;
      }
      .card:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 0 #ddd;
        border-color: var(--accent-red);
      }
      .card h3 {
        margin: 0 0 10px 0;
        color: #333;
      }
      .card-tag {
        background: #333;
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 0.7rem;
        font-weight: bold;
      }

      /* Toggle Button */
      #toggle-btn {
        position: fixed;
        bottom: 30px;
        right: 30px;
        z-index: 100;
        background: #333;
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 50px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        transition: 0.3s;
      }
      #toggle-btn:hover {
        background: var(--accent-red);
        transform: scale(1.1);
      }

      /* Modal */
      #modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.9);
        z-index: 200;
        display: none;
        justify-content: center;
        align-items: center;
      }
      #modal.active {
        display: flex;
      }
      .modal-content {
        width: 90%;
        max-width: 600px;
        text-align: center;
        background: white;
        border: 4px solid #333;
        border-radius: 20px;
        padding: 40px;
        box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.1);
      }
      .close-btn {
        background: var(--accent-red);
        color: white;
        border: none;
        padding: 10px 30px;
        font-weight: bold;
        border-radius: 30px;
        cursor: pointer;
        margin-top: 20px;
      }
    </style>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  </head>
  <body>
    <div id="start-overlay" onclick="initializeSystem()">
      <h2>WELCOME TO OZ</h2>
      <p>TAP TO LOGIN</p>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
      <h1>XANY</h1>
      <p class="subtitle">OZ NETWORK SYSTEM</p>
      <button id="back-btn" onclick="resetToMain()">▲ RETURN ROOT</button>
    </div>

    <div id="ai-container">
      <div id="ai-core"></div>
      <div id="ai-message">Ready.</div>
    </div>

    <div id="web-view">
      <div class="content-wrapper">
        <div class="web-header">
          <h2>ARCHIVES</h2>
          <p>Xany Group Database</p>
        </div>
        <div class="grid" id="card-grid"></div>
      </div>
    </div>

    <button id="toggle-btn" onclick="toggleView()">LIST VIEW</button>

    <div id="modal">
      <div class="modal-content">
        <h2 id="m-title">Title</h2>
        <p id="m-desc">Description</p>
        <button class="close-btn" onclick="closeModal()">CLOSE</button>
      </div>
    </div>

    <script>
      // --- AI System ---
      const aiCore = document.getElementById("ai-core");
      const aiMessage = document.getElementById("ai-message");
      let isSystemReady = false;

      function speak(text) {
        if (!isSystemReady) return;
        aiMessage.innerText = text;
        aiMessage.classList.add("active");
        window.speechSynthesis.cancel();

        const speakText = text.replace(/Xany/g, "ザニー");
        const uttr = new SpeechSynthesisUtterance(speakText);
        uttr.lang = "ja-JP";
        uttr.rate = 1.2;

        uttr.onstart = () => aiCore.classList.add("speaking");
        uttr.onend = () => {
          aiCore.classList.remove("speaking");
          setTimeout(() => aiMessage.classList.remove("active"), 3000);
        };
        window.speechSynthesis.speak(uttr);
      }

      function initializeSystem() {
        document.getElementById("start-overlay").style.display = "none";
        isSystemReady = true;
        speak("ようこそ、ザニー・オズ・システムへ。アカウントを認証しました。");
      }

      // --- Data ---
      const categories = [
        {
          id: "folk",
          title: "XanyFolk",
          color: "#e67e22",
          desc: "Community & AI Proposal",
          nodeType: "Proposal",
        },
        {
          id: "one",
          title: "XanyOne",
          color: "#3498db",
          desc: "Business Support Hub",
          nodeType: "Doc",
        },
        {
          id: "univ",
          title: "XanyUniversity",
          color: "#2ecc71",
          desc: "Learning & Workshop",
          nodeType: "Event",
        },
        {
          id: "geek",
          title: "XanyGeek",
          color: "#9b59b6",
          desc: "Experimental Economy",
          nodeType: "Blank",
        },
        {
          id: "media",
          title: "XanyMedia",
          color: "#333333",
          desc: "Corporate Information",
          nodeType: "Info",
        },
      ];

      // Items Generation
      categories.forEach((cat) => {
        cat.items = [];
        let count = cat.id === "geek" ? 5 : 20;
        for (let i = 0; i < count; i++) {
          cat.items.push({
            title: `${cat.title} NODE ${i + 1}`,
            desc: `Data packet for ${cat.title}.`,
            color: cat.color,
          });
        }
      });

      // --- Web View ---
      const grid = document.getElementById("card-grid");
      categories.forEach((cat) => {
        cat.items.slice(0, 3).forEach((item) => {
          const card = document.createElement("div");
          card.className = "card";
          card.style.borderTop = `5px solid ${cat.color}`;
          card.innerHTML = `<span class="card-tag" style="background:${cat.color}">${cat.title}</span><h3>${item.title}</h3><p>${item.desc}</p>`;
          card.onclick = () => openModal(item);
          grid.appendChild(card);
        });
      });

      // --- Three.js Setup (OZ Style) ---
      const container = document.getElementById("canvas-container");
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff); // 白背景
      scene.fog = new THREE.Fog(0xffffff, 50, 300); // 白い霧

      const camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        1,
        1000
      );
      camera.position.set(0, 50, 150);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      // --- OZ Elements: Floating Avatars (Background) ---
      // カラフルな浮遊物（アバターに見立てたパーティクル）
      const avatarsGeo = new THREE.BufferGeometry();
      const avatarCount = 2000;
      const avatarPos = [];
      const avatarColors = [];
      const colorPalette = [
        new THREE.Color("#e74c3c"),
        new THREE.Color("#3498db"),
        new THREE.Color("#f1c40f"),
        new THREE.Color("#2ecc71"),
        new THREE.Color("#9b59b6"),
      ];

      for (let i = 0; i < avatarCount; i++) {
        avatarPos.push(
          (Math.random() - 0.5) * 400,
          (Math.random() - 0.5) * 400,
          (Math.random() - 0.5) * 400
        );
        const c = colorPalette[Math.floor(Math.random() * colorPalette.length)];
        avatarColors.push(c.r, c.g, c.b);
      }
      avatarsGeo.setAttribute(
        "position",
        new THREE.Float32BufferAttribute(avatarPos, 3)
      );
      avatarsGeo.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(avatarColors, 3)
      );

      // 丸くてパキッとしたテクスチャ
      const canvas = document.createElement("canvas");
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext("2d");
      ctx.beginPath();
      ctx.arc(16, 16, 14, 0, Math.PI * 2);
      ctx.fillStyle = "white";
      ctx.fill();
      const circleTex = new THREE.CanvasTexture(canvas);

      const avatarMat = new THREE.PointsMaterial({
        size: 4,
        vertexColors: true,
        map: circleTex,
        alphaTest: 0.5,
        transparent: true,
      });
      const avatars = new THREE.Points(avatarsGeo, avatarMat);
      scene.add(avatars);

      // --- Grid Floor (OZ Horizon) ---
      const gridHelper = new THREE.GridHelper(500, 50, 0xeeeeee, 0xeeeeee);
      gridHelper.position.y = -50;
      scene.add(gridHelper);

      // --- Nodes with Rings (OZ Planets) ---
      const mainGroup = new THREE.Group();
      const detailGroup = new THREE.Group();
      scene.add(mainGroup);
      scene.add(detailGroup);

      // リング生成関数
      function createRing(color, radius) {
        const geometry = new THREE.TorusGeometry(radius, 0.3, 16, 100);
        const material = new THREE.MeshBasicMaterial({
          color: color,
          side: THREE.DoubleSide,
        });
        const ring = new THREE.Mesh(geometry, material);
        ring.rotation.x = Math.PI / 2;
        return ring;
      }

      // テキストラベル
      function createLabel(text, color) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = 512;
        canvas.height = 128;
        ctx.font = "bold 50px Arial";
        ctx.fillStyle = color;
        ctx.textAlign = "center";
        ctx.fillText(text, 256, 80);
        const tex = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
        sprite.scale.set(20, 5, 1);
        return sprite;
      }

      let interactables = [];

      categories.forEach((cat, i) => {
        const nodeWrapper = new THREE.Group();

        // Core Sphere (Flat shading for pop look)
        const sphereGeo = new THREE.SphereGeometry(6, 32, 32);
        const sphereMat = new THREE.MeshBasicMaterial({ color: cat.color });
        const sphere = new THREE.Mesh(sphereGeo, sphereMat);

        // Rings (Orbit)
        const ring1 = createRing(cat.color, 9);
        const ring2 = createRing(0xaaaaaa, 11);
        ring2.rotation.x = Math.PI / 3; // Tilt ring

        // Label
        const label = createLabel(cat.title, "#333333");
        label.position.y = -10;

        nodeWrapper.add(sphere);
        nodeWrapper.add(ring1);
        nodeWrapper.add(ring2);
        nodeWrapper.add(label);

        // Animation data
        nodeWrapper.userData = {
          type: "main",
          data: cat,
          rings: [ring1, ring2],
        };

        // Position
        const angle = (i / categories.length) * Math.PI * 2;
        nodeWrapper.position.set(Math.cos(angle) * 50, 0, Math.sin(angle) * 50);

        mainGroup.add(nodeWrapper);
        interactables.push(sphere); // Click target
      });

      // --- Interaction Logic ---

      function expandCategory(data) {
        speak(`${data.title} 領域に接続します。`);

        // Main nodes fly away
        new TWEEN.Tween(mainGroup.scale)
          .to({ x: 0, y: 0, z: 0 }, 800)
          .easing(TWEEN.Easing.Back.In)
          .start();
        document.getElementById("back-btn").style.display = "inline-block";

        detailGroup.clear();
        interactables = [];

        data.items.forEach((item, i) => {
          // Detail nodes are cubes (Data blocks)
          const geo = new THREE.BoxGeometry(2, 2, 2);
          const mat = new THREE.MeshBasicMaterial({
            color: item.color,
            wireframe: true,
          });
          const mesh = new THREE.Mesh(geo, mat);
          // Inside cube
          const inner = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 1.5, 1.5),
            new THREE.MeshBasicMaterial({
              color: item.color,
              transparent: true,
              opacity: 0.3,
            })
          );
          mesh.add(inner);

          const r = 20 + Math.random() * 40;
          const theta = i * 0.5;
          mesh.position.set(
            r * Math.cos(theta),
            (Math.random() - 0.5) * 20,
            r * Math.sin(theta)
          );
          mesh.scale.set(0, 0, 0);
          mesh.userData = { type: "detail", data: item };

          detailGroup.add(mesh);
          interactables.push(mesh);

          new TWEEN.Tween(mesh.scale)
            .to({ x: 1, y: 1, z: 1 }, 800)
            .delay(i * 30)
            .easing(TWEEN.Easing.Elastic.Out)
            .start();
        });

        // Camera moves closer
        new TWEEN.Tween(camera.position).to({ y: 30, z: 80 }, 1000).start();
      }

      window.resetToMain = () => {
        speak("ホームに戻ります。");
        document.getElementById("back-btn").style.display = "none";

        // Clear details
        detailGroup.children.forEach((c) =>
          new TWEEN.Tween(c.scale).to({ x: 0, y: 0, z: 0 }, 500).start()
        );

        setTimeout(() => {
          detailGroup.clear();
          new TWEEN.Tween(mainGroup.scale)
            .to({ x: 1, y: 1, z: 1 }, 1000)
            .easing(TWEEN.Easing.Elastic.Out)
            .start();

          interactables = [];
          mainGroup.children.forEach((w) => interactables.push(w.children[0])); // Re-add spheres targets

          new TWEEN.Tween(camera.position).to({ y: 50, z: 150 }, 1000).start();
        }, 600);
      };

      // Raycaster
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let isWebMode = false;

      window.addEventListener("click", (e) => {
        if (isWebMode || !isSystemReady) return;
        if (e.target.closest("button") || e.target.closest("#ai-core")) return;

        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(interactables);

        if (intersects.length > 0) {
          const target = intersects[0];
          // Check if it's a detail node or main sphere
          // Target is usually the mesh
          let parent = target.object.parent;
          if (parent.userData && parent.userData.type === "main") {
            expandCategory(parent.userData.data);
          } else if (target.object.userData.type === "detail") {
            openModal(target.object.userData.data);
          }
        }
      });

      // View Toggle
      const toggleBtn = document.getElementById("toggle-btn");
      window.toggleView = () => {
        isWebMode = !isWebMode;
        document.body.classList.toggle("web-mode");
        toggleBtn.innerText = isWebMode ? "3D WORLD" : "LIST VIEW";
        if (!isWebMode) speak("3Dワールドへ復帰。");
        else speak("リストモードを表示。");
      };

      // Modal
      const modal = document.getElementById("modal");
      window.openModal = (data) => {
        document.getElementById("m-title").innerText = data.title;
        document.getElementById("m-desc").innerText = data.desc;
        modal.classList.add("active");
      };
      window.closeModal = () => modal.classList.remove("active");

      // Loop
      function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        controls.update();

        // Rotate Rings
        mainGroup.children.forEach((wrapper) => {
          if (wrapper.userData.rings) {
            wrapper.userData.rings[0].rotation.z += 0.01;
            wrapper.userData.rings[1].rotation.z -= 0.02;
            wrapper.userData.rings[1].rotation.x += 0.005;
          }
        });

        // Float Details
        const time = Date.now() * 0.001;
        detailGroup.children.forEach((mesh, i) => {
          mesh.rotation.y += 0.01;
          mesh.position.y += Math.sin(time + i) * 0.05;
        });

        renderer.render(scene, camera);
      }
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      animate();
    </script>
  </body>
</html>
