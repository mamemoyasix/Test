<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>XANY - COLLECTIVE INTELLIGENCE</title>
    <style>
      /* --- 基本設定 --- */
      :root {
        --bg-color: #020202;
        --text-color: #ffffff;
        --accent-color: #00f3ff; /* 知的なシアン */
        --accent-secondary: #4a90e2;
      }

      body {
        margin: 0;
        background-color: var(--bg-color);
        font-family: "Helvetica Neue", Arial, sans-serif;
        color: var(--text-color);
        height: 500vh;
        overflow-x: hidden;
        overflow-y: scroll;
        user-select: none;
      }

      /* --- レイヤー構成 --- */

      /* 1. 背景 (WebGL) */
      #webgl-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        z-index: 0;
        pointer-events: none;
        transition: opacity 1s ease, filter 1s ease;
        opacity: 0.6; /* 初期は少し薄く */
      }

      /* 2. スマホ画面 (CSS3D) */
      #css3d-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        z-index: 5;
        pointer-events: none;
        opacity: 0;
        transition: opacity 1s ease;
      }

      /* 3. メインUI */
      #ui-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        z-index: 10;
        pointer-events: none;
        transition: opacity 0.5s;
      }

      /* --- 詳細モード時の変化 --- */
      body.detail-mode {
        height: 2000vh;
      }

      body.detail-mode #webgl-container {
        opacity: 1; /* 背景フェードイン */
        filter: brightness(1.2); /* 明るく */
      }
      body.detail-mode #css3d-container {
        opacity: 1;
        pointer-events: auto;
      }
      body.detail-mode #ui-container {
        opacity: 0;
        pointer-events: none;
      }

      /* --- セクション表示 --- */
      .section {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100vh;
        display: flex;
        align-items: center;
        padding: 0 10%;
        box-sizing: border-box;
        transition: opacity 0.5s, transform 0.5s;
        opacity: 0;
        transform: translateY(20px);
      }
      .section.active {
        opacity: 1;
        transform: translateY(0);
      }

      .text-wrap {
        pointer-events: auto;
        max-width: 500px;
        background: rgba(0, 0, 0, 0.7);
        padding: 40px;
        border-radius: 4px;
        backdrop-filter: blur(10px);
        border-left: 4px solid var(--accent-color);
        box-shadow: 0 0 30px rgba(0, 243, 255, 0.1);
      }

      h2 {
        font-size: 3rem;
        margin: 0 0 10px 0;
        line-height: 1;
        font-weight: 200;
        color: #fff;
        letter-spacing: 2px;
      }
      .tag {
        font-size: 0.8rem;
        letter-spacing: 4px;
        color: var(--accent-color);
        display: block;
        margin-bottom: 20px;
        font-weight: bold;
      }
      p {
        font-size: 0.95rem;
        color: #ccc;
        line-height: 1.8;
        margin-bottom: 30px;
      }

      .enter-btn {
        background: transparent;
        border: 1px solid var(--accent-color);
        color: var(--accent-color);
        padding: 15px 40px;
        border-radius: 0;
        cursor: pointer;
        transition: 0.3s;
        font-size: 0.9rem;
        letter-spacing: 3px;
        font-weight: bold;
        pointer-events: auto;
      }
      .enter-btn:hover {
        background: var(--accent-color);
        color: #000;
        box-shadow: 0 0 20px var(--accent-color);
      }

      .section:nth-child(even) {
        justify-content: flex-end;
        text-align: right;
      }
      .section:nth-child(even) .text-wrap {
        border-left: none;
        border-right: 4px solid var(--accent-secondary);
      }

      /* --- スマホ画面ノード --- */
      .phone-node {
        width: 320px;
        height: 500px;
        background: #000;
        border: 1px solid #333;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        transition: border-color 0.3s, box-shadow 0.3s;
        cursor: grab;
      }
      .phone-node:hover {
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.4);
        border-color: #fff;
        z-index: 100;
      }
      .phone-node.dragging {
        cursor: grabbing;
        border-color: var(--accent-color);
      }

      .header-bar {
        width: 100%;
        height: 30px;
        background: #1a1a1a;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 10px;
        box-sizing: border-box;
        font-size: 0.7rem;
        color: #888;
        border-bottom: 1px solid #333;
      }
      .header-dot {
        width: 8px;
        height: 8px;
        background: #555;
        border-radius: 50%;
      }

      .iframe-container {
        flex: 1;
        position: relative;
        background: #fff;
      }

      iframe {
        width: 100%;
        height: 100%;
        border: none;
        position: relative;
        z-index: 2;
        pointer-events: auto;
      }
      .phone-node.dragging iframe {
        pointer-events: none;
      }

      /* セキュリティ制限等で表示できない場合の見た目 */
      .fallback-visual {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        background: #f5f5f5;
        z-index: 1;
        color: #333;
        padding: 20px;
        box-sizing: border-box;
      }
      .fallback-title {
        font-size: 1.2rem;
        font-weight: bold;
        margin-bottom: 10px;
        color: #000;
      }
      .fallback-note {
        font-size: 0.7rem;
        color: #666;
        margin-top: 10px;
      }

      /* --- 拡大表示（フルスクリーンオーバーレイ） --- */
      #expanded-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 9999;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(10px);
        opacity: 0;
        transition: opacity 0.3s;
      }
      #expanded-overlay.active {
        display: flex;
        opacity: 1;
      }

      #expanded-content {
        width: 90%;
        height: 90%;
        background: white;
        border-radius: 8px;
        position: relative;
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        overflow: hidden;
      }
      #expanded-iframe {
        width: 100%;
        height: 100%;
        border: none;
      }

      #close-expanded {
        position: absolute;
        top: -40px;
        right: 0;
        color: white;
        background: none;
        border: none;
        font-size: 1rem;
        cursor: pointer;
        border-bottom: 1px solid transparent;
        pointer-events: auto;
      }
      #close-expanded:hover {
        border-bottom: 1px solid white;
      }

      /* --- 詳細モードUI --- */
      #detail-ui {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 50;
        opacity: 0;
        transition: opacity 0.5s;
      }
      body.detail-mode #detail-ui {
        opacity: 1;
      }

      #close-detail {
        position: absolute;
        top: 30px;
        right: 40px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #fff;
        color: white;
        padding: 10px 30px;
        border-radius: 30px;
        cursor: pointer;
        pointer-events: auto;
        font-weight: bold;
      }
      #close-detail:hover {
        background: white;
        color: black;
      }

      #detail-hint {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        color: #aaa;
        font-size: 0.8rem;
        letter-spacing: 2px;
        text-shadow: 0 2px 4px black;
      }
    </style>
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  </head>
  <body>
    <!-- 3D Layers -->
    <div id="webgl-container"></div>
    <div id="css3d-container"></div>

    <!-- UI Layers -->
    <div id="ui-container">
      <!-- 5 Sections -->
      <div class="section active">
        <div class="text-wrap">
          <span class="tag">01 / COMMUNITY</span>
          <h2>XanyFolk</h2>
          <p>
            集合知の形成。<br />無数のノードが結合し、新たな知性を生み出します。
          </p>
          <button class="enter-btn" onclick="enterDetail(0)">
            ENTER CLUSTER
          </button>
        </div>
      </div>
      <div class="section">
        <div class="text-wrap">
          <span class="tag">02 / BUSINESS</span>
          <h2>XanyOne</h2>
          <p>
            構造化されたビジネスインテリジェンス。<br />秩序あるグリッド管理。
          </p>
          <button class="enter-btn" onclick="enterDetail(1)">
            ENTER CLUSTER
          </button>
        </div>
      </div>
      <div class="section">
        <div class="text-wrap">
          <span class="tag">03 / ACADEMY</span>
          <h2>XanyUniv</h2>
          <p>知識の螺旋。<br />進化し続ける学習ログのアーカイブ。</p>
          <button class="enter-btn" onclick="enterDetail(2)">
            ENTER CLUSTER
          </button>
        </div>
      </div>
      <div class="section">
        <div class="text-wrap">
          <span class="tag">04 / ECONOMY</span>
          <h2>XanyGeek</h2>
          <p>
            経済圏の循環。<br />トランザクションが織りなす円筒状のネットワーク。
          </p>
          <button class="enter-btn" onclick="enterDetail(3)">
            ENTER CLUSTER
          </button>
        </div>
      </div>
      <div class="section">
        <div class="text-wrap">
          <span class="tag">05 / MEDIA</span>
          <h2>XanyMedia</h2>
          <p>情報の拡散。<br />世界中に広がるニュースの波。</p>
          <button class="enter-btn" onclick="enterDetail(4)">
            ENTER CLUSTER
          </button>
        </div>
      </div>
    </div>

    <!-- 詳細モードUI -->
    <div id="detail-ui">
      <button id="close-detail" onclick="exitDetail()">CLOSE CLUSTER ×</button>
      <div id="detail-hint">
        SCROLL TO ZOOM / DRAG TO MOVE / DOUBLE CLICK TO EXPAND
      </div>
    </div>

    <!-- 拡大表示用オーバーレイ -->
    <div id="expanded-overlay">
      <div style="position: relative; width: 90%; height: 90%">
        <button id="close-expanded" onclick="closeExpanded()">CLOSE ×</button>
        <div id="expanded-content">
          <iframe id="expanded-iframe" src=""></iframe>
        </div>
      </div>
    </div>

    <!-- スクロール制御 -->
    <div id="scroll-dummy"></div>

    <script>
      // --- 設定: Wikipedia URLs ---
      const WIKI_URLS = [
        "https://en.wikipedia.org/wiki/History",
        "https://en.wikipedia.org/wiki/Science",
        "https://en.wikipedia.org/wiki/Architecture",
        "https://en.wikipedia.org/wiki/Artificial_intelligence",
        "https://en.wikipedia.org/wiki/Quantum_mechanics",
        "https://en.wikipedia.org/wiki/World_War_II",
        "https://en.wikipedia.org/wiki/Modernism",
        "https://en.wikipedia.org/wiki/Japan",
        "https://en.wikipedia.org/wiki/Coffee",
        "https://en.wikipedia.org/wiki/Bauhaus",
        "https://en.wikipedia.org/wiki/Sustainable_development",
        "https://en.wikipedia.org/wiki/Urban_planning",
        "https://en.wikipedia.org/wiki/Philosophy",
        "https://en.wikipedia.org/wiki/Information_technology",
        "https://en.wikipedia.org/wiki/Climate_change",
        "https://en.wikipedia.org/wiki/Art_Deco",
        "https://en.wikipedia.org/wiki/Neuroscience",
        "https://en.wikipedia.org/wiki/International_relations",
        "https://en.wikipedia.org/wiki/Printing_press",
        "https://en.wikipedia.org/wiki/Internet",
      ];

      const CONFIG = {
        webNodeCount: 20,
        colors: [0x00f3ff, 0x4a90e2, 0x2ecc71, 0x9b59b6, 0xffffff],
      };

      // --- Init Renderers ---
      const webglContainer = document.getElementById("webgl-container");
      const css3dContainer = document.getElementById("css3d-container");

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = "absolute";
      webglContainer.appendChild(renderer.domElement);

      const cssRenderer = new THREE.CSS3DRenderer();
      cssRenderer.setSize(window.innerWidth, window.innerHeight);
      cssRenderer.domElement.style.position = "absolute";
      css3dContainer.appendChild(cssRenderer.domElement);

      const scene = new THREE.Scene();
      const cssScene = new THREE.Scene();
      // 集合知っぽさを出すため、少し明るめのフォグを使用しない、または薄く
      scene.fog = new THREE.FogExp2(0x020202, 0.001);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        10000
      );
      camera.position.z = 100;

      // --- 1. 背景：集合知（ニューラルネットワーク風） ---
      // ノード（点）とコネクション（線）
      const particleCount = 800;
      const particles = new THREE.BufferGeometry();
      const pPos = new Float32Array(particleCount * 3);
      const pVel = []; // 動き用

      for (let i = 0; i < particleCount; i++) {
        pPos[i * 3] = (Math.random() - 0.5) * 3000;
        pPos[i * 3 + 1] = (Math.random() - 0.5) * 2000;
        pPos[i * 3 + 2] = (Math.random() - 0.5) * 3000;

        pVel.push({
          x: (Math.random() - 0.5) * 0.5,
          y: (Math.random() - 0.5) * 0.5,
          z: (Math.random() - 0.5) * 0.5,
        });
      }
      particles.setAttribute("position", new THREE.BufferAttribute(pPos, 3));

      // 光る点
      const pMat = new THREE.PointsMaterial({
        color: 0x4a90e2,
        size: 3,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });
      const particleSystem = new THREE.Points(particles, pMat);
      scene.add(particleSystem);

      // 線（近傍結合）- 計算コスト削減のため、LineSegmentsで静的に描画せず、
      // 今回は「視覚的に密度の高い点群」で集合知を表現し、詳細モードで線を表示するアプローチを取ります。
      // パフォーマンス確保のため、詳細モードでのみラインを表示。
      const lineGeo = new THREE.BufferGeometry();
      // 最大本数
      const linePosArr = new Float32Array(CONFIG.webNodeCount * 10 * 3);
      lineGeo.setAttribute(
        "position",
        new THREE.BufferAttribute(linePosArr, 3)
      );
      const lineMat = new THREE.LineBasicMaterial({
        color: 0x00f3ff,
        transparent: true,
        opacity: 0,
      });
      const bgLines = new THREE.LineSegments(lineGeo, lineMat);
      scene.add(bgLines);

      // --- 2. スマホノード (CSS3D) ---
      const cssObjects = [];

      for (let i = 0; i < CONFIG.webNodeCount; i++) {
        const url = WIKI_URLS[i % WIKI_URLS.length];
        const title = url.split("/").pop().replace(/_/g, " ");

        const wrapper = document.createElement("div");
        wrapper.className = "phone-node";

        const header = document.createElement("div");
        header.className = "header-bar";
        header.innerHTML = `<span>${title}</span><div class="header-dot"></div>`;
        wrapper.appendChild(header);

        const content = document.createElement("div");
        content.className = "iframe-container";

        // Wikipedia用フォールバック
        const fallback = document.createElement("div");
        fallback.className = "fallback-visual";
        fallback.innerHTML = `
                <div class="fallback-title">${title}</div>
                <div class="fallback-note">Double click to expand</div>
                <div style="font-size:0.6rem; color:#999; margin-top:5px;">(Wiki embedding may vary)</div>
            `;
        content.appendChild(fallback);

        const iframe = document.createElement("iframe");
        iframe.src = url;
        iframe.onload = () => {
          /* WikipediaはCORSでここ発火しないことが多いが念のため */
        };
        content.appendChild(iframe);

        wrapper.appendChild(content);

        const object = new THREE.CSS3DObject(wrapper);
        object.position.set(0, 0, -20000); // 画面外
        object.scale.set(0.5, 0.5, 0.5);

        cssScene.add(object);
        cssObjects.push(object);

        wrapper.userData = { object: object, url: url };

        // イベント設定
        setupInteractions(header, wrapper, url);
      }

      // --- インタラクション (ドラッグ & ダブルクリック) ---
      function setupInteractions(handle, wrapper, url) {
        let isDragging = false;
        let startMouse = { x: 0, y: 0 };
        let startPos = { x: 0, y: 0 };

        // ドラッグ開始 (ヘッダー部分のみ)
        handle.addEventListener("mousedown", (e) => {
          isDragging = true;
          wrapper.classList.add("dragging");
          startMouse = { x: e.clientX, y: e.clientY };
          const obj = wrapper.userData.object;
          startPos = { x: obj.position.x, y: obj.position.y };
          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("mouseup", onMouseUp);
          e.preventDefault();
        });

        function onMouseMove(e) {
          if (!isDragging) return;
          const dx = e.clientX - startMouse.x;
          const dy = e.clientY - startMouse.y;
          const moveScale = 3.0;
          const obj = wrapper.userData.object;
          obj.position.x = startPos.x + dx * moveScale;
          obj.position.y = startPos.y - dy * moveScale;
        }

        function onMouseUp() {
          isDragging = false;
          wrapper.classList.remove("dragging");
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
        }

        // ダブルクリックで拡大
        wrapper.addEventListener("dblclick", () => {
          openExpanded(url);
        });
      }

      // --- 拡大表示機能 ---
      const expandedOverlay = document.getElementById("expanded-overlay");
      const expandedIframe = document.getElementById("expanded-iframe");

      function openExpanded(url) {
        expandedIframe.src = url;
        expandedOverlay.classList.add("active");
      }

      window.closeExpanded = () => {
        expandedOverlay.classList.remove("active");
        setTimeout(() => {
          expandedIframe.src = "";
        }, 300); // 消えてからリセット
      };

      // --- 配置計算 (数学的配置) ---
      function getClusterPosition(type, index, count) {
        const pos = new THREE.Vector3();
        const spread = 1200;

        switch (type) {
          case 0: // Sphere (Fibonacci)
            const phi = Math.acos(-1 + (2 * index) / count);
            const theta = Math.sqrt(count * Math.PI) * phi;
            pos.setFromSphericalCoords(spread, phi, theta);
            break;
          case 1: // Grid
            const cols = 5;
            const spX = 500;
            const spY = 700;
            const c = index % cols;
            const r = Math.floor(index / cols);
            pos.set((c - cols / 2) * spX, (r - count / cols / 2) * spY, 0);
            break;
          case 2: // Helix
            const ang = index * 0.5;
            const rad = 800;
            pos.set(
              Math.cos(ang) * rad,
              (index - count / 2) * 150,
              Math.sin(ang) * rad
            );
            break;
          case 3: // Cylinder
            const rows = 4;
            const perRow = count / rows;
            const ri = Math.floor(index / perRow);
            const ci = index % perRow;
            const ca = (ci / perRow) * Math.PI * 2;
            pos.set(
              Math.cos(ca) * spread,
              (ri - rows / 2) * 600,
              Math.sin(ca) * spread
            );
            break;
          case 4: // Random Sphere
            const u = Math.random();
            const v = Math.random();
            const t = 2 * Math.PI * u;
            const p = Math.acos(2 * v - 1);
            const rr = spread * (0.8 + Math.random() * 0.4);
            pos.setFromSphericalCoords(rr, p, t);
            break;
        }
        return pos;
      }

      // --- ライン描画 (ノード間の結合) ---
      function updateLines() {
        if (!isDetailMode) return;
        const positions = bgLines.geometry.attributes.position.array;
        let idx = 0;

        // 単純にindex順で近いものをつなぐ（視覚的演出）
        for (let i = 0; i < CONFIG.webNodeCount; i++) {
          const p1 = cssObjects[i].position;
          // 2つの近隣と結ぶ
          const neighbors = [
            (i + 1) % CONFIG.webNodeCount,
            (i + 3) % CONFIG.webNodeCount,
          ];

          neighbors.forEach((n) => {
            const p2 = cssObjects[n].position;
            positions[idx++] = p1.x;
            positions[idx++] = p1.y;
            positions[idx++] = p1.z;
            positions[idx++] = p2.x;
            positions[idx++] = p2.y;
            positions[idx++] = p2.z;
          });
        }
        bgLines.geometry.attributes.position.needsUpdate = true;
      }

      // --- 状態管理 & スクロール ---
      let currentSection = 0;
      let isDetailMode = false;
      let cameraTargetZ = 100;

      window.addEventListener("scroll", () => {
        const scrollY = window.scrollY;

        if (!isDetailMode) {
          // メインモード
          const h = window.innerHeight;
          const idx = Math.floor((scrollY + h * 0.5) / h);
          if (idx !== currentSection && idx >= 0 && idx < 5) {
            currentSection = idx;
            document.querySelectorAll(".section").forEach((el, i) => {
              if (i === idx) el.classList.add("active");
              else el.classList.remove("active");
            });
          }
        } else {
          // 詳細モード：ズーム
          const maxScroll = document.body.scrollHeight - window.innerHeight;
          const progress = scrollY / maxScroll;
          cameraTargetZ = 3500 - progress * 7000;
        }
      });

      // --- トランジション ---
      window.enterDetail = (type) => {
        isDetailMode = true;
        document.body.classList.add("detail-mode");
        window.scrollTo(0, 0);

        camera.position.z = 3500;
        cameraTargetZ = 3500;

        // 背景ラインを表示
        new TWEEN.Tween(bgLines.material).to({ opacity: 0.3 }, 2000).start();

        // ノード集合
        cssObjects.forEach((obj, i) => {
          const target = getClusterPosition(type || 0, i, CONFIG.webNodeCount);
          // 遠くから飛んでくる
          const startX = (Math.random() - 0.5) * 10000;
          const startY = (Math.random() - 0.5) * 10000;
          obj.position.set(startX, startY, -5000);
          obj.rotation.set(0, 0, 0);

          new TWEEN.Tween(obj.position)
            .to({ x: target.x, y: target.y, z: target.z }, 1500)
            .easing(TWEEN.Easing.Exponential.Out)
            .delay(Math.random() * 300)
            .start();
        });
      };

      window.exitDetail = () => {
        isDetailMode = false;
        document.body.classList.remove("detail-mode");
        window.scrollTo(0, 0);

        // ライン非表示
        new TWEEN.Tween(bgLines.material).to({ opacity: 0 }, 500).start();

        // ノード退避
        cssObjects.forEach((obj) => {
          new TWEEN.Tween(obj.position).to({ z: -20000 }, 1000).start();
        });

        // カメラ戻す
        new TWEEN.Tween(camera.position).to({ z: 100 }, 1000).start();

        // セクションリセット
        currentSection = 0;
        document.querySelectorAll(".section").forEach((el, i) => {
          if (i === 0) el.classList.add("active");
          else el.classList.remove("active");
        });
      };

      // --- Loop ---
      function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();

        // 背景パーティクルの揺らぎ (集合知の鼓動)
        const positions = particleSystem.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] += pVel[i].x;
          positions[i * 3 + 1] += pVel[i].y;
          positions[i * 3 + 2] += pVel[i].z;

          // 境界ループ
          if (Math.abs(positions[i * 3]) > 1500) pVel[i].x *= -1;
          if (Math.abs(positions[i * 3 + 1]) > 1000) pVel[i].y *= -1;
          if (Math.abs(positions[i * 3 + 2]) > 1500) pVel[i].z *= -1;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;

        // カメラ制御
        if (isDetailMode) {
          camera.position.z += (cameraTargetZ - camera.position.z) * 0.05;
          camera.lookAt(0, 0, -5000);
          updateLines(); // ライン更新
        } else {
          camera.lookAt(0, 0, 0);
          const t = Date.now() * 0.0002;
          camera.position.x = Math.sin(t) * 30;
          camera.position.y = Math.cos(t * 0.8) * 30;
          particleSystem.rotation.y += 0.0005;
        }

        renderer.render(scene, camera);
        cssRenderer.render(cssScene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        cssRenderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
      document.querySelector(".section").classList.add("active");
    </script>
  </body>
</html>
